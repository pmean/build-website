---
title: "Basics of cubic spline models"
author: "Steve Simon"
date: "2021-11-01"
categories:
- Recommendation
tags:
- Linear regression
output: html_document
---

```{r setup}
suppressMessages(suppressWarnings(library(broom)))
suppressMessages(suppressWarnings(library(dplyr)))
suppressMessages(suppressWarnings(library(knitr)))
suppressMessages(suppressWarnings(library(magrittr)))
suppressMessages(suppressWarnings(library(splines)))
suppressMessages(suppressWarnings(library(tidyr)))
```

### Artificial data

Suppose you have some data where you suspect the behavior differs for x=1 to 5, x=6 to 10, x=11 to 15, and x=16 to 20.

```{r}
library(ggplot2)
x <- 0:20
y <- rep(40, 21)
y[6:21] <- y[6:21]-3*(0:15)
y[11:21] <- y[11:21]+7*(0:10)
y[16:21] <- y[16:21]-(0:5)^2
y <- y+round(rnorm(21), 1)
simulated_example <- data.frame(x, y)
simulated_example
ggplot(simulated_example, aes(x, y)) +
  geom_point()
```

To make the graphs look nice, you need to include some intermediate values.

```{r}
x <- c(0:20, setdiff(seq(0, 20, by=1/64), 0:20))
```

You can get a variety of splines by defining constant, linear, quadratic, and cubic terms and then shift those functions to the right. After shifting, fill in the hole to the left with zeros.

```{r}
xm <- data.frame(
  c1 =rep(1, length(x)),
  c2 =x,
  c3 =x^2,
  c4 =x^3,
  c5 =(x> 5)*rep(1, length(x)),
  c6 =(x> 5)*(x- 5),
  c7 =(x> 5)*(x- 5)^2,
  c8 =(x> 5)*(x- 5)^3,
  c9 =(x>10)*rep(1, length(x)),
  c10=(x>10)*(x-10),
  c11=(x>10)*(x-10)^2,
  c12=(x>10)*(x-10)^3,
  c13=(x>15)*rep(1, length(x)),
  c14=(x>15)*(x-15),
  c15=(x>15)*(x-15)^2,
  c16=(x>15)*(x-15)^3,
  x=x,
  y=NA
)
xm$y[1:21] <- y
```


```{r}
display_terms <- function(df, lb) {
  names(df) <- c("x", "y")
  integer_data <- df[1:21, ]
  ggplot(df, aes(x, y)) +
      ggtitle(lb) +
      geom_line() +
      geom_point(data=integer_data, aes(x, y)) +
      xlab(" ") +
      ylab(" ")
}

lb1 <- rep(c("Intercept", "Linear term", "Quadratic term", "Cubic term"), 4)
lb2 <- rep(c("for the full range", "restarted at x=5", "restarted at x=10", "restarted at x=15"), each=4)
lb <- paste(lb1, lb2)

for (j in 1:16) {
  xm %>% 
    select(c(17, j)) %>%
    display_terms(lb[j]) -> cplot
  plot(cplot)
}

```

### Single cubic polynomial

This is the matrix of independent variables for a single cubic polynomial.

```{r}
kable(xm[1:21, 1:4])
```

The graph shown below represents the best fitting single cubic polynomial.

```{r}
display_fit <- function(model_fit, lb) {
  model_fit %>%
    augment(newdata=xm) %>%
      ggplot(aes(c2, .fitted)) +
        ggtitle(lb) +
        geom_line() +
        geom_point(aes(c2, y), na.rm=TRUE) +
      xlab(" ") +
      ylab(" ")
}

lm(y~c2+c3+c4, data=xm) %>%
  display_fit("Single cubic fit")
```

### Separate cubic polynomials

So, we could fit a cubic model for the first five data points, for the second five, the third five, and the fourth five. This is a bit much: a cubic model has four parameters, so fitting four of them would use up 16 degrees of freedom in a data set with only 20 observations. But bear with me a bit on this.

The trick to fitting four separate cubic polynomials is to "restart" the cubic terms after x=5, x=10, and x=15.

```{r}
kable(xm[1:20, ])
```

```{r}

lm(y~c2+c3+c4+c5+c6+c7+c8+c9+c10+c11+c12+c13+c14+c15+c16, data=xm)  %>%
  display_fit("Discontinous cubic splines")
```


This function is not continuous or smooth. To make the function continuous, drop the extra intercept terms.

```{r}
kable(xm[1:20, c(1:4, 6:8, 10:12, 14:16)])
lm(y~c2+c3+c4+c6+c7+c8+c10+c11+c12+c14+c15+c16, data=xm)  %>%
  display_fit("Continous but not smooth cubic splines")
```

Smoothness is measured in terms of the continuity of derivatives. Here is a function that has a continuous first derivative.

```{r}
kable(xm[1:20, c(1:4, 7:8, 11:12, 15:16)])
lm(y~c2+c3+c4+c7+c8+c11+c12+c15+c16, data=xm) %>%
  display_fit("Continous and Smooth (1st derivative) splines")

```

Here is a function that has continuous first and second derivatives.

```{r}
kable(xm[1:20, c(1:4, 8, 12, 16)])
lm(y~c2+c3+c4+c8+c12+c16, data=xm) %>%
  display_fit("Continous and smooth (1st and 2nd derivatives) cubic splines")
```

While this approach is simple, there is an issue with multicollinearity.

```{r}
round(cor(xm[c(2:4, 8, 12, 16)]), 2)
```

This approach is simple and easy to follow, but there is one catch. The correlations are quite high and this can lead to computational problems, including rounding errors. So most spline models implemented on a computer use a different approach.

B-splines provide a solution with less issues of multi-collinearity.

```{r}
linear_spline <- bs(xm$c2, knots=c(5, 10, 15), degree=1, intercept=TRUE)
kable(linear_spline[1:21, ])
```

```{r}
display_matrix <- function(df, lb) {
  names(df) <- c("x", "y")
  integer_data <- df[1:21, ]
  ggplot(df, aes(x, y)) +
      ggtitle(lb) +
      geom_line() +
      geom_point(data=integer_data, aes(x, y)) +
      xlab(" ") +
      ylab(" ")
}
for (j in 1:dim(linear_spline)[2]) {
  cbind(xm$c2, linear_spline[ , j]) %>% 
    data.frame %>%
    display_matrix("Linear spline terms") %>%
    plot
}
```


```{r}
lm(xm$y~linear_spline) %>%
  display_fit("Linear splines")
```

```{r}
quadratic_spline <- bs(xm$c2, knots=c(5, 10, 15), degree=2, intercept=TRUE)
kable(quadratic_spline[1:21, ])

for (j in 1:dim(quadratic_spline)[2]) {
  cbind(xm$c2, quadratic_spline[ , j]) %>% 
    data.frame %>%
    display_matrix("Quadratic spline terms") %>%
    plot
}
```

```{r}
lm(xm$y~quadratic_spline) %>%
  display_fit("Quadratic splines")
```

```{r}
cubic_spline <- bs(xm$c2, knots=c(5, 10, 15), degree=3, intercept=TRUE)
kable(cubic_spline[1:21, ])
```


```{r}
for (j in 1:dim(cubic_spline)[2]) {
  cbind(xm$c2, cubic_spline[ , j]) %>% 
    data.frame %>%
    display_matrix("Cubic spline terms") %>%
    plot
}
```

```{r}
lm(xm$y~cubic_spline) %>%
  display_fit("Cubic splines")
```


```{r}
natural_spline <- ns(xm$c2, knots=c(5, 10, 15), intercept=TRUE)
kable(natural_spline[1:21, ])
```


```{r}
for (j in 1:dim(natural_spline)[2]) {
  cbind(xm$c2, natural_spline[ , j]) %>% 
    data.frame %>%
    display_matrix("Natural spline terms") %>%
    plot
}
```

```{r}
lm(xm$y~natural_spline) %>%
  display_fit("Natural splines")
```

